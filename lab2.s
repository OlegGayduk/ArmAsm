init:
 mov r0,#0                ;счетчик 
 mov r1,#0                ;промежуточное произведение C
 mov r2,#19                ;множимое A
 mov r3,#-5               ;множитель B
 mov r4,#1                
 mov r2,r2,lsl #3         ;сдвигаем множимое влево на 3 (n-1) разряда

loop:
 ands r6,r4,r3            ;получаем младший бит множителя путем маскирования с помощью вспомогательной единицы в регистре r4
 moveq r5,#0              ;если равен нулю, то заносим в r5 0
 movne r5,r2              ;если не равен нулю, то заносим в r5 r2
 add r1,r5,r1             ;Cj + A*b = Cj+1
 mov r1,r1,asr #1         ;C*2^-1 (сдвиг промежуточного произведения вправо на один разряд)
 mov r4,r4,lsl #1         ;сдвигаем единицу влево на один разряд
 add r0,r0,#1             ;инкрементируем счетчик
 cmp r0,#3                ;сравниваем счетчик с количеством разрядов n-1 (4-1=3)
 blt loop                 ;если счетчик меньше 3, то переходим в начало цикла

 cmp r3,#0	
 blt corr                 ;если множитель меньше нуля, то переход на коррекцию
 bgt finish               ;если множитель больше нуля, то перейти в конец программы

corr:
 mvn r2,r2                ;загрузить регистр отрицательной константой (mvn)
 add r5,r2,#1             
 add r1,r1,r5             ;сложение с псевдорезультатом

finish:                   ;результат в регистре r1
 .end
